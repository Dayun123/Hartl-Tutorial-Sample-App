In this chapter we explore some elements of the Ruby programming language.

# ********************* 4.1.1 Built-in Helpers **************************** #

In our app/layouts/application.html.erb file, the following line is present:

<%= stylesheet_link_tag 'application', media: 'all',
                                      'data-turbolinks-track': 'reload' %>

There are 4 Ruby ideas in this line:
1.  Built-in Rails methods = stylesheet_link_tag
2.  Method invocation with missing parens =

      stylesheet_link_tag('application', media: 'all',
                                      'data-turbolinks-track': 'reload')

      stylesheet_link_tag 'application', media: 'all',
                                      'data-turbolinks-track': 'reload'

3.  Symbols = media: (ends in colon)
4.  Hashes

      media: 'all', 'data-turbolinks-track': 'reload'
     {media: 'all', 'data-turbolinks-track': 'reload'}

# ********************* 4.1.2: Custom Helpers *************************** #

Rails comes with many built-in helpers for views, but also allows the creation of new ones, called 'helpers'.

In our app/layouts/application.html.erb file, we have this code in the <title> tag:

  <%= yield(:title) %> | Ruby on Rails Tutorial Sample App

Which relies on a call to 'provide' in each of our views:

  <% provide(:title, "Home") %>

And renders the following HTML

  <title>Home | Ruby on Rails Tutorial Sample App</title>

But, if we leave out the call to 'provide' in a page's view template file, the title will be rendered like so:

  <title>| Ruby on Rails Tutorial Sample App</title>

Notice the leading '|' character.

It would be nice to have an appropriate base title that is displayed if no :title variable is present from a call to 'provide'. We can create a custom helper called full_title in app/helpers/application_helper.rb to do just that.

Once the helper is created, we can use it in our layout file by replacing:

  <title><%= yeild(:title) %> | Ruby on Rails Tutorial Sample App</title>

with:

  <title><%= full_title(yeild(:title)) %></title>

Let's put this helper to work by getting rid of the "Home" page_title in the home.html.erb template. First, we need to rewrite the test condition to test for:

  assert_selector "title", "#{@base_title}"

instead of:

  assert_selector "title", "Home | #{@base_title}"

# ********************* 4.2: String Methods *************************** #

One of the principle tools for working with Ruby on the command line is irb, and since we are focusing on Rails-flavored Ruby we will use the Rails console to experiment with different Ruby functionality.

I'm using irb-tools/more, but the tutorial has you edit the .irbrc file to setup some specific settings. To run the console, type: `rails console`

The console starts in a development environment by default (as opposed to production or test).

# ********************** 4.2.1: Comments ****************************** #

Comments in Ruby are represented by the '#' character. Anything after that character is not processed by the Ruby interpreter.

# ********************* 4.2.2: Strings ******************************** #

Strings are one of the most important data structures in a web application since most of the information sent from web pages to the server is sent as Strings. Here are some String literals:

""
"foo"
"puppy"

Here is a method to 'add' two strings together, called concatenation:

"foo" + "bar"     #=> "foobar"
"cat" + "burgler" #=> "catburgler"

You can also build up strings using interpolation:

first_name = "Daniel"
"#{first_name} Schroeder" #=> "Daniel Schroeder"
last_name = "Schroeder"
"#{first_name} #{last_name}" #=> "Daniel Schroeder"

To print a string to the screen, you can use 'puts' or 'print', the only difference is whether a newline is added after the text:

>> puts "foo" #=> nil
foo
>> print "foo"    #=> nil
foo>>

Ruby supports single and double-qoutoed strings, the only difference being that single-quoted strings don't support interpolation:

>> first_name = "Daniel" #=> "Daniel"
>> "#{first_name} Schroeder" #=> "Daniel Schroeder"
>> '#{first_name} Schroeder' #=> "\#{first_name} Schroeder"

Notice also that the single-quoted string version used the backslash escape character to escape the # symbol.

Exercises:

1. Assign varibales city and state to your current residence:

>> city = "New Orleans" #=> "New Orleans"
>> state = "LA" #=> "LA"

2. Using interpolation, print a string consisting of the city and state separated by a comma and space, as in Los Angeles, CA:

>> puts "#{city}, #{state}" #=> nil
New Orleans, LA

3. Repeate the previous exercise but with the city and state separated by a tab character:

>> puts "#{city}\t#{state}" #=> nil
New Orleans LA

4. What is the result if you replace double quotes with single quotes in the previous exercise?

>> puts '#{city}\t#{state}' #=> nil
#{city}\t#{state}

# ***************** 4.2.3: Objects and Message Passing ********************* #

Everything in Ruby is an object, and all objects do things by responding to messages. For example, String objects respond to the .length message:

"foobar".length #=> 6

The messages that get passed to objects are 'methods' of those objects. Strings respond to other messages besides .length, like .empty? :

>> "".empty? #=> true
>> "hello".empty? #=> false

The question mark at the end of .empty? is a Ruby convention for signfiying that this method returns a boolean value, and these values are especially useful in control flow statements:

>> s = "foobar" #=> "foobar"
>> if s.empty?
>>   puts "The string is empty"
>> else
>>   puts "The string is not empty"
>> end #=> nil
The string is not empty

You can also use elsif for multiple conditions:

>> if s.nil?
>>   puts "The string is nil"
>> elsif s.empty?
>>   puts "The string is empty"
>> elsif s.include?("foo")
>>   puts "The string includes foo"
>> end #=> nil
The string includes foo

You can combine booleans with the &&, ||, and ! operators:

>> x = "foo" #=> "foo"
>> y = "" #=> ""
>> puts "Both strings are empty" if x.empty? && y.empty? #=> nil
>> puts "One string is empty" if x.empty? || y.empty? #=> nil
One string is empty
>> puts "x is not empty" if !x.empty?
x is not empty

Since everything in Ruby is an object that can respond to methods, if follows that nil is also an object that can respond to methods:

>> nil.to_s #=> ""

We can chain messages together like so:

>> nil.to_s.empty? #=> true

You can use the .nil? method to test for nil-ness:

>> "foo".nil? #=> false
>> "".nil? #=> false
>> false.nil? #=> false
>> nil.nil? #=> true

In addition to 'if', Ruby supports the opposite 'unless' statement:

>> s = "foo" #=> "foo"
>> puts "s is empty" if s.empty? #=> nil
>> puts "s is not empty" unless s.empty? #=> nil
s is not empty

nil is the only object that is false in a boolean context besides 'false' itself. You can test this by using !!, which negates an object twice therefore yielding its boolean value.

>> !!nil #=> false
>> !!0   #=> true

Notice that 0 is actually true in Ruby, as opposed to many other languages.

Exercises:

1. What is the length of the string "racecar"?

>> "racecar".length #=> 7

2. Confirm using the reverse method that the string from the previous exercise is the same when its reversed:

>> "racecar".reverse #=> "racecar"

3. Assign the string "racecar" to the variable s. Confirm using the comparison operator that s and s.reverse are equal:

>> s = "racecar" #=> "racecar"
>>
>> puts "s and s.reverse are equal" if s.reverse == s #=> nil
s and s.reverse are equal

4. What is the result of running this code?

>> s = "racecar" #=> "racecar"
>> puts "It's a palindrome" if s == s.reverse #=> nil

Answer:
It's a palindrome

4 (continued). How does it change if you reassign 's' to onomatopoeia?

>> s = "onomotopoeia" #=> "onomotopoeia"
>> puts "It's a palindrome" if s == s.reverse #=> nil


# ******************** 4.2.4: Method Definitions ************************* #

We can define methods in the console, although it is a bit cumbersome. Let's define a method that takes a single argument and returns a message based on whether or not the string is empty:

>> def string_message(str = '')
>>   if str.empty?
>>     "It's an empty string"
>>   else
>>     "The string is non-empty"
>>   end
>> end
=> :string_message
>> puts string_message("hello")
The string is non-empty
=> nil
>> puts string_message("")
It's an empty string
=> nil
>> puts string_message()
It's an empty string
=> nil

As we can see from the final example, it's possible to leave the argument to string_message out entirely because we made the argument a default argument with the line:

def string_message(str = '')

Ruby functions have implicit returns, meaning they return the last statement evaluated, but they can have explicity returns as well:

>> def string_message_explicit(str = '')
>>   return "The string is empty" if str.empty?
>>   return "The string is not empty"
>> end
=> :string_message_explicit
>> puts string_message_explicit("hello")
The string is not empty
=> nil
>> puts string_message_explicit("")
The string is empty
=> nil

Exercises:

1. Define a method for testing palindromes that prints "It's a palindrome" or "It's not a palindrome":

>> def palindrome_tester(s)
>>   if s.reverse == s
>>     puts "It's a palindrome"
>>   else
>>     puts "It's not a palindrome"
>>   end
>> end

2. By running your palindrome_tester on 'racecare' and 'onomatopoeia' confirm that the first is a palindrome and the second is not.

>> palindrome_tester('racecar')
It's a palindrome
=> nil
>> palindrome_tester('onomatopoeia')
It's not a palindrome
=> nil

3. Call the .nil? method on the palindrome_tester('racecar') call and confirm that the method returns nil. This is because the last statement evaluated is a 'puts' call, and 'puts' returns nil.

>> palindrome_tester('racecar').nil?
It's a palindrome
=> true

# ***************** 4.2.5: Back to the Title Helper ************************ #

We can now understand all the elements of the title_helper we made earlier, except the 'Module' keyword. Modules give us a way to package some new functionality into a class, usually by using the 'include' keyword in the class that we want to contain the Module in. Rails takes care of this part for us, so any methods we define in the ApplicationHelper module are packaged in to our app.

# ******************* 4.3: Other Data Structures ************************ #

Web apps are ultimately concerned with strings, but there are other data structures that come into play when creating those strings, and those data structures will be the focus of this section.

# ********************** 4.3.1: Arrays and Ranges *********************** #

An array is just a list of elements in a particular order. Since we have been talking about strings, let's convert a string to an array using the .split method:

>> "foo bar baz".split
=> ["foo", "bar", "baz"]

.split divides a string into an array by splitting the parameter supplied, or whitespace if no param is supplied. Here, we are splitting on the character 'x':

>> "fooxbarxbazx".split('x')
=> ["foo", "bar", "baz"]

Arrays in Ruby, as in most languages, are zero-offset, meaning the first element can be accessed by arr[0]:

=> ["foo", "bar", "baz"]
>> arr = [54, 1, 17]
=> [54, 1, 17]
>> arr[0]
=> 54
>> arr[1]
=> 1
>> arr[2]
=> 17
>> arr[-1]
=> 17

Notice that negative indicies are allowed as well.

In addition to bracket notation, Ruby offers several methods that provide access to common array elements:

>> arr
=> [54, 1, 17]
>> arr.first
=> 54
>> arr[0]
=> 54
>> arr.last
=> 17
>> arr[-1]
=> 17
>> arr.last == arr[-1]
=> true
>> arr.first == arr[0]
=> true

Arrays respond to many methods, just like strings. Here are a few:

>> arr
=> [54, 1, 17]
>> arr.length
=> 3
>> arr.include?(54)
=> true
>> arr.empty?
=> false
>> arr.shuffle
=> [1, 17, 54]
>> arr.sort
=> [1, 17, 54]
>> arr
=> [54, 1, 17]

Note that none of the methods change the array itself, if you want to do that use the corresponding ! (bang) methods:

>> arr
=> [54, 1, 17]
>> arr.sort!
=> [1, 17, 54]
>> arr
=> [1, 17, 54]
>> arr.shuffle!
=> [54, 17, 1]
>> arr
=> [54, 17, 1]

You can also add to arrays with the .push method or the equivalent << (shovel) operator:

>> arr
=> [54, 17, 1]
>> arr.push(6)
=> [54, 17, 1, 6]
>> arr << 99
=> [54, 17, 1, 6, 99]
>> arr << "hello" << "steve"
=> [54, 17, 1, 6, 99, "hello", "steve"]

The last examples shows how you can chain multiple << together, and also how arrays in Ruby can contain mixed data types.

We saw that .split converts strings to arrays, but you can go the other way as well and convert an array to a string using .join:

>> arr
=> [54, 17, 1, 6, 99, "hello", "steve"]
>> arr.join
=> "54171699hellosteve"
>> arr.join(', ')
=> "54, 17, 1, 6, 99, hello, steve"

The parameter you pass to .join will be what the elements of the array are joined with.

Ranges are closely related to arrays, and they are most easily understood by converting them to arrays with the .to_a method:

>> 0..9
=> 0..9
>> 0..9.to_a
Traceback (most recent call last):
        1: from (irb):42
NoMethodError (undefined method `to_a' for 9:Integer)
>> (0..9).to_a
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

Notice how you must surround the range with () in order to call methods on the array.

You can use ranges to select a number of elements from an array:

>> arr = %w[foo bar baz quix]
=> ["foo", "bar", "baz", "quix"]
>> arr[0..2]
=> ["foo", "bar", "baz"]

Notice that we can also use the %w notation to convert the string [foo bar baz quix] into an array.

A useful trick with ranges is to use -1 as the last number of the range to select every element of an array from the start of the range to the end of the array:

>> arr = (0..9).to_a
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>> arr[2..(arr.length - 1)]
=> [2, 3, 4, 5, 6, 7, 8, 9]
>> arr[2..-1]
=> [2, 3, 4, 5, 6, 7, 8, 9]

Ranges also work with characters:

>> ('a'..'e').to_a
=> ["a", "b", "c", "d", "e"]

Exercises:

1. Assign arr to be the result of splitting the string "A man, a plan, a canal, Panama" on comma-space.

>> arr = "A man, a plan, a canal, Panama".split(', ')
=> ["A man", "a plan", "a canal", "Panama"]

2. Assign str to be the string resulting from joining arr to nothing:

>> str = arr.join
=> "A mana plana canalPanama"

3. Split str on whitespace and rejoin on nothing. Use the palindrome test to determine that the string is not a palindrome in it's current state, but is when it is run through the .downcase method:

>> str = str.split.join
=> "AmanaplanacanalPanama"
>> str == str.reverse
=> false
>> str.downcase == str.downcase.reverse
=> true

4. What is the result of selecting element 7 from the range 'a' through 'z'? What about the same range reversed?

>> alphabet = ('a'..'z').to_a
=> ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
>> alphabet[7]
=> "h"
>> alphabet.reverse[7]
=> "s"

# **************************** 4.3.2: Blocks **************************** #

Blocks are one of the most powerful features in Ruby. Here is a simple block:

>> (1..5).each { |i| puts 2 * i }
2
4
6
8
10
=> 1..5

The code above calls the 'each' method for each number in the range, assigning the number to the block variable, 'i', and then running the code in the block once for each member of the range.

You can denote blocks with {} or with do...end. Here is the same block from above but with do...end format:

>> (1..5).each do |i|
?>   puts 2 * i
>> end
2
4
6
8
10
=> 1..5

For one-line blocks, curly-braces are the conventional notation, but for multi-line blocks use do...end:

>> (1..5).each do |number|
?>   puts 2 * number
>>   puts '--'
>> end
2
--
4
--
6
--
8
--
10
--
=> 1..5

Notice that we can use whatever name we want for the block variable.

Here are a few more methods that take blocks:

>> 3.times { puts 'Beetlejuice' } # .times has no block variable
Beetlejuice
Beetlejuice
Beetlejuice
=> 3
>> %w[a b c] # %w creates a string array
=> ["a", "b", "c"]
>> %w[a b c].map { |char| char.upcase }
=> ["A", "B", "C"] # .map runs the block and adds the results to an array
>> %w[A B C].map { |char| char.downcase }
=> ["a", "b", "c"]
>> (1..5).map { |num| num**2 }
=> [1, 4, 9, 16, 25] # ** is the exponent method

There is an alternate way to use the .map function, using symbol to proc notation:

>> %w[a b c].map(&:upcase)
=> ["A", "B", "C"]
>> %w[a b c].map { |char| char.upcase }
=> ["A", "B", "C"]

Notice how map(&:upcase) is the same as map { |char| char.upcase }

We can now understand this code from chapter 1:

>> ('a'..'z').to_a.shuffle[0..7].join
=> "qhizrsyb"

We see it as a combination of each method:

# The range
>> ('a'..'z')
=> "a".."z"
# The range converted to an array
>> ('a'..'z').to_a
=> ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
# Range convert to array then shuffled
>> ('a'..'z').to_a.shuffle
=> ["h", "j", "r", "z", "k", "f", "a", "n", "x", "i", "p", "d", "e", "m", "g", "u", "w", "y", "t", "q", "l", "o", "b", "s", "c", "v"]
# Range convert to array, shuffled, then get the first 8 elements
>> ('a'..'z').to_a.shuffle[0..7]
=> ["y", "j", "e", "f", "g", "a", "s", "x"]
# Range convert to array, shuffled, first eight elements as a string
>> ('a'..'z').to_a.shuffle[0..7].join
=> "mcfzryxq"

Exercises:

1. Using the range 0..16, print out the first 17 powers of 2:

>> (0..16).each { |i| puts i**2 }
0
1
4
9
16
25
36
49
64
81
100
121
144
169
196
225
256
=> 0..16

2. Define a method called 'yeller' that takes an array of characters and returns a string with an all caps version of the input. Ex:

yeller(%w[h e l l o]) #=> 'HELLO'

>> def yeller(char_arr)
>>   char_arr.map(&:upcase).join
>> end
=> :yeller
>> yeller(%w[h e l l o])
=> "HELLO"

3. Define a method called 'random_subdomain' that returns a randomly generated string of eight characters:

>> def random_subdomain
>>   ('a'..'z').to_a.shuffle[0..7].join
>> end
=> :random_subdomain
>> random_subdomain
=> "gxydpcwv"

4. Combine split, shuffle, and join to write a function that shuffles the letters in a given string:

>> def string_shuffle(s)
>>   s.split('').shuffle.join
>> end
=> :string_shuffle
>> string_shuffle('hello')
=> "hlelo"

# ********************* 4.3.3: Hashes and Symbols ************************** #

Hashes are arrays with key->value pairs where the key is not limited to integers.

>> user = {}
=> {}
>> user["first_name"] = 'Daniel'
=> "Daniel"
>> user
=> {"first_name"=>"Daniel"}
>> user['last_name'] = 'Schroeder'
=> "Schroeder"
>> user
=> {"first_name"=>"Daniel", "last_name"=>"Schroeder"}
>> user['first_name']
=> "Daniel"

Hashes look similar to arrays, but until Ruby 1.9 they didn't guarantee any particular ordering, so if order matters, use an Array.

Instead of defining hashes one member at a time, you can use the literal notation to define a hash like so:

>> user = { "first_name" => "Ella", "last_name" => "Schroeder" }
=> {"first_name"=>"Ella", "last_name"=>"Schroeder"}

While you can use strings as keys to your hashes, in Rails it's much more common to use symbols, which are just named values preceded by a colon that don't have as much overhead as strings:

>> 'foo'.length
=> 3
>> :foo.length
=> 3
>> 'foo'.reverse
=> "oof"
>> :foo.reverse
Traceback (most recent call last):
        1: from (irb):18
NoMethodError (undefined method `reverse' for :foo:Symbol)
>> 'foo'.split('')
=> ["f", "o", "o"]
>> :foo.split('')
Traceback (most recent call last):
        1: from (irb):20
NoMethodError (undefined method `split' for :foo:Symbol)

Notice that symbols don't share many of the string methods.

You can use symbols as keys to hashes, and this is very common in Rails:

>> user = { :name => 'Daniel', :email => 'Daniel@aol.com' }
=> {:name=>"Daniel", :email=>"Daniel@aol.com"}
>> user[:name]
=> "Daniel"
>> user[:password]
=> nil

Notice that if you try to access a hash key that doesn't exist, the return value is nil.

As of Ruby 1.9, you can define key->value pairs that have a symbol as the key like so:

>> hash1 = { :name => "Daniel", :email => "Man@aol.com" }
=> {:name=>"Daniel", :email=>"Man@aol.com"}
>> hash2 = { name: "Daniel", email: "Man@aol.com" }
=> {:name=>"Daniel", :email=>"Man@aol.com"}
>> hash1 == hash2
=> true

So { :name => "Daniel" } is equiv to { name: "Daniel" }

It's important to note that the special key->value use of symbols is only valid inside hashes, you must prepend the colon if you want to use a symbol in any other context.

Hashes can be other hashes:

>> params = {}
=> {}
>> params[:user] = { name: "Daniel Schroeder", email: "Man@aol.com" }
=> {:name=>"Daniel Schroeder", :email=>"Man@aol.com"}
>> params
=> {:user=>{:name=>"Daniel Schroeder", :email=>"Man@aol.com"}}
>> params[:user][:email]
=> "Man@aol.com"

Hashes respond to the .each method, just like arrays and ranges. The difference is the hash version yeilds a key,value pair to the block:

>> flash = { success: "It worked!", failure: "It failed!" }
=> {:success=>"It worked!", :failure=>"It failed!"}
>> flash.each do |key, value|
?>   puts "Key: #{key.inspect}\tValue: #{value.inspect}"
>> end
Key: :success Value: "It worked!"
Key: :failure Value: "It failed!"
=> {:success=>"It worked!", :failure=>"It failed!"}

Note the use of the .inspect method, which returns a string with a literal representation of the object it was called on:

>> puts (1..5).to_a
1
2
3
4
5
=> nil
>> puts (1..5).to_a.inspect
[1, 2, 3, 4, 5]
=> nil
>> puts :name, :name.inspect
name
:name
=> nil
>> puts "It worked!", "It worked!".inspect
It worked!
"It worked!"
=> nil

Printing values with inspect is so common there's a shortcut for it, 'p':

>> p :user
:user
=> :user
>> p "It worked!"
"It worked!"
=> "It worked!"
>> p (1..5).to_a
[1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]

Note that 'p' returns the value it gets, where as 'puts' returns nil.

Exercises:

1. Define a hash with the keys ’one’, ’two’, and ’three’, and the values ’uno’, ’dos’, and ’tres’. Iterate over the hash, and for each key/value pair print out "’#{key}’ in Spanish is ’#{value}’:

>> nums = { 'one' => 'uno', 'two' => 'dos', 'three' => 'tres' }
=> {"one"=>"uno", "two"=>"dos", "three"=>"tres"}
>> nums.each do |key, value|
?>   puts "#{key} in Spanish is #{value}"
>> end
one in Spanish is uno
two in Spanish is dos
three in Spanish is tres
=> {"one"=>"uno", "two"=>"dos", "three"=>"tres"}

2. Create three hashes called person1, person2, and person3, with first and last names under the keys :first and :last. Then create a params hash so that params[:father] is person1, params[:mother] is person2, and params[:child] is person3. Verify that, for example, params[:father][:first] has the right value:

>> person1 = { first: 'Anakin', last: 'Skywalker' }
=> {:first=>"Anakin", :last=>"Skywalker"}
>> person2 = { first: 'Padme', last: 'Amidala' }
=> {:first=>"Padme", :last=>"Amidala"}
>> person3 = { first: 'Luke', last: 'Skywalker' }
=> {:first=>"Luke", :last=>"Skywalker"}
>> params = {}
=> {}
>> params[:father] = person1
=> {:first=>"Anakin", :last=>"Skywalker"}
>> params[:mother] = person2
=> {:first=>"Padme", :last=>"Amidala"}
>> params[:child] = person3
=> {:first=>"Luke", :last=>"Skywalker"}
>> params[:father][:first]
=> "Anakin"

3. Define a hash with symbol keys corresponding to name, email, and a “password digest”, and values equal to your name, your email address, and a random string of 16 lower-case letters:

>> hash = { name: "Daniel Schroeder", email: "DanielSchroederMusic@gmail.com", password_digest: ('a'..'z').to_a.shuffle[0..15].join }
=> {:name=>"Daniel Schroeder", :email=>"DanielSchroederMusic@gmail.com", :password_digest=>"fcesljuvmtdbzrwy"}

4. Find an online version of the Ruby API and read about the Hash method merge. What is the value of the following expression?

{ "a" => 100, "b" => 200}.merge({ "b" => 300 })

The online API states that .merge will combine the contents of the hash it is called on with the hash passed in as an argument, and any duplicate values between them will be replaced with the values from the hash in the argument, so the call above will result in the following:

>> { "a" => 100, "b" => 200 }.merge({ "b" => 300 })
=> {"a"=>100, "b"=>300}

# ************************* 4.3.4: CSS Revisited *************************** #

We can now make sense of this line which inserts the CSS into our layout:

<%= stylesheet_link_tag 'application', media: 'all'
                                       'data-turbolinks-track': 'reload' %>

This is a call to the stylesheet_link_tag function, but it omits the parens, which are optional, the following two function calls are idential:

stylesheet_link_tag('application', media: 'all',
                                   'data-turbolinks-track': 'reload')
stylesheet_link_tag 'application', media: 'all'
                                      'data-turbolinks-track': 'reload'

Also, the media: 'all' part looks like a hash, but there are no braces, because braces are also optional in hashses when they are passed as a function argument as long as they are the last argument of the function. The following two calls to the function are equivalent:

stylesheet_link_tag 'application', { media: 'all'
                                      'data-turbolinks-track': 'reload }
stylesheet_link_tag 'application', media: 'all'
                                      'data-turbolinks-track': 'reload

Finally, we notice that Ruby correctly interprets the function, even though we've split it across two lines. This is because the newlines are ignored inside a function call, so we can split the arguments up on newlines for visual formatting and not mess up the interpreter.


# ************************ 4.4: Ruby Classes ***************************** #

Everything in Ruby is an object, and objects come from classes, which are used to organize methods. Classes can be instantiated into objects.

# ************************* 4.4.1: Constructors ***************************** #

We've already used classes to instantiate objects, take to literal constructor, the quote characters, which instantiate String objects as an example:

>> s = "foobar"
=> "foobar"
>> s.class
=> String

Notice the call to .class shows that the string is indeed of class String.

We can also use a named constructor, which is equivalent to the literal constructor:

>> s1 = String.new("foobar")
=> "foobar"
>> s2 = "foobar"
=> "foobar"
>> s1.class
=> String
>> s2.class
=> String
>> s1 == s2
=> true

Arrays have literal and named constructors as well, but they are both equivalent just like strings:

>> arr1 = Array.new([2, 3, 4])
=> [2, 3, 4]
>> arr2 = [2, 3, 4]
=> [2, 3, 4]
>> arr1.class
=> Array
>> arr2.class
=> Array
>> arr1 == arr2
=> true

The Hash constructor is a little bit different, in that the named constructor takes as an argument the value that a nonexistent key should return:

>> hash = Hash.new
=> {}
>> hash[:nope]
=> nil
>> hash = Hash.new(:empty)
=> {}
>> hash[:you_here]
=> :empty

Methods that are called on the class are called class methods, and the 'new' method instantiates an object of the given class. Methods called on instances of a class are called instance methods.

Exercises:

1. What is the literal constructor for the range of integers from 1 to 10?

>> (1..10)
=> 1..10

2. What is the constructor using the Range class and the new method?

>> Range.new(1, 10)
=> 1..10

3. Confirm using the == operator that the literal and named constructors from the previous two exercises are identical.

>> (1..10) == Range.new(1, 10)
=> true


# ********************* 4.4.2 Class Inheritance ************************** #

We can find out the class hierarchy of a given class using the superclass method:

>> s = String.new('foo')
=> "foo"
>> s.class
=> String
>> s.class.superclass
=> Object
>> s.class.superclass.superclass
=> BasicObject
>> s.class.superclass.superclass.superclass
=> nil

We can see from the above code that the String class has a superclass of Object, and Object's superclass is BasicObject, and then there is nothing above this. Ultimately, everything in Ruby traces back to BasicObject.

To understand classes, it is instructive to make your own. Let's make a Word class that has a method palindrome? that returns ture if the word is a palindrome:

>> class Word
>>   def palindrome?(string)
>>     string == string.reverse
>>   end
>> end
=> :palindrome?

We can use this class as follows:

>> word = Word.new
=> #<Word:0x0000000003b4acf0>
>> word.palindrome?('foobar')
=> false
>> word.palindrome?('level')
=> true

This example is a bit contrived though. Isn't a Word really just a String? Let's make the Word class inherit from String:

>> class Word < String
>>   def palindrome?
>>     self == self.reverse
>>   end
>> end
=> :palindrome?

The line 'Word < String' shows that Word inherits from String, so it will have all the same methods associated with Strings:

>> s = Word.new('level')
=> "level"
>> s.palindrome?
=> true
>> s.length
=> 5

Since the Word class inherits from String, we can use the superclass method to see the inheritance hierarchy:

>> s.class
=> Word
>> s.class.superclass
=> String
>> s.class.superclass.superclass
=> Object
>> s.class.superclass.superclass.superclass
=> BasicObject

Notice in the new definition of the Word class when we want to refer to the Word itself inside the class we use the 'self' keyword:

  self == self.reverse

When you are inside the Word class, since .reverse is a method of the String class, which Word inherits from, you don't have to write self.reverse, you can just do:

  self == reverse

Exercises:

1. What is the class hierarchy for a range? For a hash? For a symbol?

>> range = Range.new(0, 5)
=> 0..5
>> range.class
=> Range
>> range.class.superclass
=> Object
>> range.class.superclass.superclass
=> BasicObject

>> hash = Hash.new
=> {}
>> hash.class.superclass
=> Object
>> hash.class.superclass.superclass
=> BasicObject

>> symbol = :foo
=> :foo
>> symbol.class
=> Symbol
>> symbol.class.superclass
=> Object
>> symbol.class.superclass.superclass
=> BasicObject

2. Confirm that the method shown in Listing 4.15 works even if we replace self.reverse with just reverse.

>> class Word < String
>>   def palindrome?
>>     self == reverse
>>   end
>> end
=> :palindrome?
>> word = Word.new('level')
=> "level"
>> word.palindrome?
=> true

# ****************** 4.4.3: Modifying Built-in Classes ******************** #

In some cases, inheritance might not be the best option. Take the palindrome? method we created in our Word class that inherited from String. Wouldn't it be nice to just ask any String if it is a palindrome, like so:

"foobar".palindrome?

Ruby allows you to do just this, by opening and modifying the String class like so:

>> class String
>>   def palindrome?
>>     self == self.reverse
>>   end
>> end
=> :palindrome?
>> "deified".palindrome?
=> true

While technically you can modify the built-in Ruby classes, you should have a really good reason to do so. In web applications, we often want to make sure that a variable contains something other than whitespace, but Ruby doesn't provide a method to do this natively. So, the Rails creators added a method .blank? that checks if a string has characters other than whitespace:

>> "".empty?
=> true
>> "".blank?
=> true
>> "    ".empty?
=> false
>> "    ".blank?
=> true
>> nil.empty?
Traceback (most recent call last):
        1: from (irb):12
NoMethodError (undefined method `empty?' for nil:NilClass)
>> nil.blank?
=> true

Note that the above example won't work in IRB, since you need the Rails extensions to Ruby present you must use the rails console. Notice that the .blank? method even works on the nil object, which means it must be defined on a superclass of String, since nil is not a string.

1. Verify that “racecar” is a palindrome and “onomatopoeia” is not. What about the name of the South Indian language “Malayalam”? Hint: Downcase it first:

>> "racecar".palindrome?
=> true
>> "onomatopoeia".palindrome?
=> false
>> "Malayalam".downcase.palindrome?
=> true

2. Using Listing 4.16 as a guide, add a shuffle method to the String class. Hint: Refer to Listing 4.12:

>> class String
>>   def shuffle
>>     self.split('').shuffle.join
>>   end
>> end
=> :shuffle
>> "hello".shuffle
=> "lhloe"

3. Verify that the shuffle method works even if you remove self:

>> class String
>>   def shuffle
>>     split('').shuffle.join
>>   end
>> end
=> :shuffle
>> "hello".shuffle
=> "ohlel"

















